# Руководство по фронтенд-фреймворкам: Сравнительный обзор

Этот документ предоставляет теоретический и практический обзор фронтенд-фреймворков,
используемых и рассматриваемых для проекта Phoebe CMS, с акцентом на размер
зависимостей, структуру проекта и лучшие практики разработки.

---

## 1. Понимание `node_modules` и размера зависимостей

Распространенное наблюдение в современной веб-разработке — большой размер директории
`node_modules`. Это нормально и ожидаемо. Давайте разберем, почему папка
`node_modules` нашего проекта Next.js составляет примерно 350-400 МБ.

### 1.1. Ключевые зависимости и их влияние

Размер в основном объясняется несколькими ключевыми зависимостями, которые
составляют основу нашего стека:

*   **`@next` (112 МБ, версия 14.x)** и **`next` (101 МБ, версия 14.x)**: Эти пакеты
    содержат сам фреймворк Next.js, включая его компилятор (SWC), сервер разработки,
    движок серверного рендеринга, генератор статических сайтов и различные оптимизации.
    Размер отражает его комплексный характер "все включено".
*   **`@mui` (27 МБ, версия 5.x)**: Material-UI — это богатая библиотека компонентов.
    Этот размер включает не только компоненты, но и движки стилизации, возможности
    темизации и служебные функции.
*   **`typescript` (23 МБ)**: Компилятор TypeScript и связанные с ним определения типов.
    Next.js имеет встроенную поддержку TypeScript, что делает его стандартной зависимостью.
*   **Другие пакеты**: Оставшийся размер распределен между более чем 320 мелкими
    пакетами, которые включают утилиты, полифиллы и различные другие зависимости,
    необходимые основным фреймворкам.

### 1.2. Почему раньше было меньше?

Меньший размер `node_modules` в прошлом мог быть обусловлен несколькими причинами:
*   **Неполная установка**: Были установлены не все зависимости.
*   **Другой менеджер пакетов**: `yarn` или `pnpm` могут создавать другую структуру
    директорий или использовать кэширование более агрессивно, чем `npm`.
*   **Очистка кэша**: Недавняя очистка кэша (`npm cache clean --force`) могла
    привести к принудительной загрузке всех пакетов заново.

**Вывод**: Размер `node_modules` в 300-400 МБ является стандартным для современного
проекта Next.js с крупной UI-библиотекой, такой как Material-UI.

---

## 2. Сравнение размеров фреймворков: Next.js против Angular

Хотя наша текущая реализация использует Next.js, полезно сравнить ее с Angular,
другой запланированной эталонной реализацией.

| Фреймворк         | Типичный размер `node_modules` | Основные факторы                               |
|-------------------|--------------------------------|------------------------------------------------|
| **Next.js**       | **~350-400 МБ**                | Фреймворк Next.js, SWC, React, Material-UI     |
| **Angular**       | **~500-700 МБ**                | Angular CLI, DevKit, RxJS, Zone.js, Webpack    |
| **Vue.js**        | ~200-300 МБ                    | Ядро Vue, Vite, меньшая экосистема             |
| **React (CRA)**   | ~250-350 МБ                    | React-scripts, Webpack, Babel                  |

### 2.1. Почему Angular "тяжелее"?

Больший размер Angular — это компромисс за его универсальную, предписывающую структуру:

*   **Angular CLI и DevKit (~250+ МБ)**: Мощный набор инструментов для сборки,
    тестирования и поддержки приложения.
*   **RxJS (~15 МБ)**: Ключевая зависимость для обработки асинхронных операций.
*   **Zone.js (~10 МБ)**: Управляет обнаружением изменений.
*   **Полный набор инструментов**: Angular поставляется со своими собственными решениями
    для маршрутизации, форм, HTTP-запросов и тестирования, все включено по умолчанию.

**Вывод**: Больший размер `node_modules` у Angular — это плата за полностью
интегрированный фреймворк корпоративного уровня, где многие архитектурные решения
принимаются за вас.

---

## 3. Git, `node_modules` и лучшие практики

Критически важное правило в веб-разработке — **никогда не коммитить директорию
`node_modules` в Git**.

### 3.1. Что коммитить, а что игнорировать

*   **✅ Коммитить в Git**:
    *   `package.json`: Перечисляет все зависимости проекта.
    *   `package-lock.json`: "Фиксирует" точные версии каждой зависимости,
        обеспечивая согласованные установки во всех средах. Это гарантирует
        детерминированные сборки.
    *   Исходный код (`/pages`, `/components`, `/styles` и т.д.).
    *   Конфигурационные файлы (`next.config.js`, `tsconfig.json`).

*   **❌ Игнорировать в `.gitignore`**:
    *   `node_modules/`: Все установленные пакеты зависимостей.
    *   `.next/`: Результат процесса сборки Next.js.
    *   `.env.local`: Локальные переменные окружения и секреты.
    *   Файлы, специфичные для IDE (`.vscode/`, `.idea/`).
    *   Файлы логов (`*.log`).

### 3.2. Рабочий процесс

Такое разделение обеспечивает эффективный и безопасный процесс разработки:

1.  Разработчик клонирует репозиторий (загружает только исходный код, который мал).
    ```bash
    git clone <repository_url>
    ```
2.  Переходит в директорию фронтенда (например, `frontends/nextjs`).
    ```bash
    cd frontends/nextjs
    ```
3.  Устанавливает зависимости локально на основе файла `package-lock.json`.
    Это воссоздает директорию `node_modules` на его машине.
    ```bash
    npm install
    ```
4.  **Запускает бэкенд** (если еще не запущен):
    ```bash
    cd ../.. # Возвращаемся в корень проекта
    docker compose up --build # Или make run
    ```
5.  Запускает сервер разработки фронтенда.
    ```bash
    npm run dev
    ```

Эта практика экономит место в репозитории, ускоряет клонирование и процессы CI/CD,
а также позволяет избежать проблем, специфичных для платформы.

### 3.3. Методы экономии места

Хотя `node_modules` должен быть большим, вы можете управлять дисковым пространством
с помощью следующих методов:
*   **`npm ci`**: Для сред CI/CD это обеспечивает более быструю и чистую установку,
    так как устанавливает зависимости строго по `package-lock.json`.
*   **`.dockerignore`**: Убедитесь, что `node_modules` указан здесь, чтобы
    предотвратить его копирование в образ Docker во время сборки.
*   **Многостадийные сборки Docker (Multi-stage Docker Builds)**: Распространенный
    шаблон, при котором зависимости устанавливаются на промежуточном этапе "сборщика",
    и только окончательные артефакты сборки копируются в облегченный производственный образ.
