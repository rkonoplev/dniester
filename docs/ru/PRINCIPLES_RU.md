# Принципы проектирования в проекте

Данный проект спроектирован с учетом фундаментальных принципов разработки программного обеспечения,
таких как SOLID, KISS и YAGNI. Это обеспечивает создание гибкой, поддерживаемой и понятной архитектуры.
Этот документ описывает, как эти принципы применяются в кодовой базе.

[English Version](./PRINCIPLES.md)

---

## Принципы SOLID

SOLID — это акроним для пяти принципов объектно-ориентированного проектирования, которые помогают
создавать легко поддерживаемые и расширяемые системы.

### 1. S — Single Responsibility Principle (Принцип единственной ответственности)

-   **Принцип:** У каждого класса или компонента должна быть только одна причина для изменения.
-   **Реализация в проекте:** Этот принцип является основой архитектуры. Код четко разделен на слои
    (контроллеры, сервисы, репозитории), и каждый компонент выполняет строго свою задачу.
    -   **`NewsController`** отвечает только за обработку HTTP-запросов, связанных с новостями.
    -   **`NewsService`** инкапсулирует бизнес-логику, касающуюся только новостей.
    -   **`UserRepository`** отвечает только за операции с данными пользователей.
    -   Такое разделение предотвращает появление "классов-богов" и упрощает навигацию по коду.

### 2. O — Open/Closed Principle (Принцип открытости/закрытости)

-   **Принцип:** Программные сущности должны быть открыты для расширения, но закрыты для модификации.
-   **Реализация в проекте:** Проявляется в использовании фреймворка Spring и его подходов.
    -   **Spring Security:** Для добавления нового способа аутентификации (например, OAuth 2.0) не требуется
        изменять существующий код. Вместо этого создается новая конфигурация, которая **расширяет** систему.
    -   **Сервисный слой:** Новую функциональность можно добавлять с помощью новых методов или даже новых
        классов-сервисов, которые используют существующие, не изменяя их.

### 3. L — Liskov Substitution Principle (Принцип подстановки Барбары Лисков)

-   **Принцип:** Объекты в программе должны быть заменяемыми на экземпляры их подтипов без изменения
    правильности выполнения программы.
-   **Реализация в проекте:** Обеспечивается за счет программирования на уровне интерфейсов.
    -   Сервисы (`NewsService`) зависят от интерфейсов репозиториев (`NewsRepository`), а не от их конкретных
        реализаций. Spring Data JPA "на лету" создает прокси-реализацию, соответствующую этому интерфейсу.
        Это позволяет в будущем, при необходимости, подменить реализацию (например, для тестов) без
        изменения кода сервиса.

### 4. I — Interface Segregation Principle (Принцип разделения интерфейса)

-   **Принцип:** "Клиенты не должны зависеть от методов, которые они не используют".
-   **Реализация в проекте:** Проявляется в создании небольших, сфокусированных интерфейсов для каждой
    доменной области.
    -   Интерфейс `NewsService` содержит только методы для работы с новостями. Он не включает методы для
        управления пользователями или ролями, которые вынесены в `UserService` и `RoleService`. Это
        предотвращает появление "раздутых" интерфейсов и делает зависимости между компонентами более явными.

### 5. D — Dependency Inversion Principle (Принцип инверсии зависимостей)

-   **Принцип:** Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба должны зависеть
    от абстракций. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.
-   **Реализация в проекте:** Это центральный принцип, на котором построен Spring Framework.
    -   **`NewsController`** (верхний уровень) зависит от абстракции `NewsService` (интерфейс), а не от
        конкретного класса `NewsServiceImpl` (нижний уровень).
    -   Зависимости не создаются внутри классов, а "внедряются" извне с помощью механизма Dependency Injection
        (`@Autowired`). Это инвертирует контроль над зависимостями, передавая его фреймворку.

---

## Прагматичные принципы

### KISS (Keep It Simple, Stupid)

Этот принцип гласит, что большинство систем работают лучше всего, если они остаются простыми, а не
усложняются без необходимости.

-   **Реализация в проекте:**
    -   **Выбор технологического стека:** Для основного функционала был выбран классический, хорошо изученный
        и надежный стек (Spring Boot + JPA). Более сложный реактивный подход (WebFlux + R2DBC) был осознанно
        отложен на будущее, чтобы не усложнять разработку на ранних этапах.
    -   **Прямолинейная логика:** Бизнес-логика в сервисах реализована максимально просто и понятно, без
        избыточных слоев абстракции или преждевременной оптимизации.

### YAGNI (You Ain't Gonna Need It / Вам это не понадобится)

Этот принцип экстремального программирования гласит, что функциональность не следует добавлять до тех пор,
пока она не станет действительно необходимой.

-   **Реализация в проекте:**
    -   **Фокус на MVP:** Проект сфокусирован на реализации ключевой функциональности Headless CMS (управление
        контентом, пользователями, ролями). Такие функции, как полнотекстовый поиск, загрузка файлов или
        интеграция с Telegram, были вынесены в "Технический долг" как будущие задачи, а не реализованы
        "про запас".
    -   **Отсутствие преждевременной оптимизации:** Оптимизация производительности (например, переход на
        реактивный стек) планируется только после того, как реальные измерения покажут наличие "бутылочных
        горлышек", а не заранее.
