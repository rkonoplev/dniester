# Эволюция Testcontainers и стратегия

Этот документ объясняет эволюцию стратегий тестирования в проекте Phoebe CMS и предоставляет руководство о том, когда использовать Testcontainers.

---

## Текущий статус реализации

**Унифицированная стратегия Testcontainers** во всех средах:

- **Unit тесты**: Используют моки без зависимостей от базы данных
- **Интеграционные тесты**: Используют Testcontainers MySQL через `BaseIntegrationTest` (везде)
- **Локальная разработка**: Testcontainers MySQL (автоматическое управление жизненным циклом)
- **CI среда**: Testcontainers MySQL (не требуется Docker Compose)
- **Консистентность продакшена**: Все среды используют реальные экземпляры MySQL

---

## Исторический контекст: Зачем был нужен Testcontainers

### Первоначальное назначение
Testcontainers изначально рассматривался для:

1. **Локальных интеграционных тестов** - Запуск тестов без необходимости настройки Docker Compose
2. **Изоляции тестов** - Каждый набор тестов получает свой контейнер базы данных
3. **Автоматического управления жизненным циклом** - Контейнеры запускаются/останавливаются автоматически с тестами
4. **Опыта разработчика** - Не требуется ручная настройка базы данных

### Предыдущий подход (с Testcontainers)
```java
@Testcontainers
class IntegrationTest {
    @Container
    static MySQLContainer mysql = new MySQLContainer("mysql:8.0")
            .withDatabaseName("testdb")
            .withUsername("test")
            .withPassword("test");
    
    // Автоматически запускает/останавливает MySQL для каждого теста
}
```

---

## Эволюция текущей архитектуры

### Современный унифицированный подход Testcontainers

**Unit тесты:**
- **Без базы данных** - Чистые моки для быстрого выполнения
- **Профиль**: `test`
- **Преимущества**: Мгновенный запуск, изолированное тестирование

**Интеграционные тесты (все среды):**
- **MySQL через Testcontainers** - Реальные экземпляры БД везде
- **Профиль**: `integration-test`
- **Класс**: `BaseIntegrationTest`
- **Преимущества**: Идентичные среды, автоматическое управление жизненным циклом, без ручной настройки

**Продакшен:**
- **База данных MySQL** - Идентична всем тестовым средам
- **Профиль**: `prod`
- **Преимущества**: 100% консистентность во всех средах

### Сравнение архитектур

| Аспект | Предыдущий гибридный подход | Текущий унифицированный Testcontainers |
|--------|----------------------------|----------------------------------------|
| **Соответствие продакшену** | Высокое (MySQL везде) | Высокое (MySQL везде) |
| **Надежность тестов** | Средняя (различия сред) | Высокая (идентичные среды) |
| **Консистентность CI** | Средняя (Docker Compose vs Testcontainers) | Высокая (Testcontainers везде) |
| **Сложность настройки** | Высокая (множественные конфигурации) | Низкая (единый подход) |
| **Использование ресурсов** | Средне | Оптимизировано (автоматическое управление) |

---

## Почему мы приняли Testcontainers

### Технические преимущества
1. **Консистентность продакшена** - Одна технология БД во всех средах
2. **Надежность тестов** - Нет проблем совместимости баз данных
3. **Изоляция** - Каждый набор тестов получает чистое состояние БД
4. **Автоматическое управление** - Контейнеры запускаются/останавливаются автоматически

### Стратегические преимущества
1. **Подход "продакшн-первый"** - Тестирование точно отражает продакшен
2. **Упрощенная архитектура** - Нет сложности абстракции БД
3. **Уверенность разработчика** - Тесты валидируют реальные продакшн-сценарии
4. **Надежность CI/CD** - Консистентное поведение во всех средах

---

## Когда использовать Testcontainers

### ✅ Рекомендуемые сценарии

**1. Сложные взаимодействия с базой данных**
- Тестирование хранимых процедур
- Специфичные для базы данных функции (различия MySQL vs PostgreSQL)
- Сложные сценарии транзакций

**2. Тестирование нескольких баз данных**
- Тестирование против нескольких версий баз данных
- Валидация совместимости между базами данных
- Тестирование миграций баз данных

**3. Интеграция с внешними сервисами**
- Тестирование с Redis, Elasticsearch и т.д.
- Интеграция очередей сообщений (RabbitMQ, Kafka)
- Мокирование сторонних сервисов

**4. Изолированные тестовые среды**
- Когда тесты не должны мешать друг другу
- Тестирование сценариев повреждения данных
- Тестирование производительности с реалистичными объемами данных

### ❌ Не рекомендуемые сценарии

**1. Простые CRUD операции**
- Базовая персистентность сущностей
- Стандартные JPA операции
- Тестирование простой бизнес-логики

**2. Быстрые циклы разработки**
- Юнит-тестирование
- TDD рабочие процессы
- Быстрое прототипирование

**3. Среды с ограниченными ресурсами**
- Ограниченные ресурсы CI/CD
- Ноутбуки разработчиков с ограниченной RAM
- Общие среды разработки

---

## Стратегия реализации

### Текущая реализация: MySQL-only с Testcontainers

**Детали реализации:**
- **Unit тесты** - Разделены в директорию `/unit/`, используют только моки
- **Интеграционные тесты** - Расположены в директории `/integration/`, используют Testcontainers
- **AbstractIntegrationTest** - Базовый класс с конфигурацией MySQL контейнера
- **Конфигурация Gradle** - Правильное разделение sourceSets

**Текущее использование (унифицированный подход):**

**Все среды (локальная и CI)**
```java
@ActiveProfiles("integration-test")
@Testcontainers
class MyIntegrationTest extends BaseIntegrationTest {
    // Testcontainers MySQL настраивается автоматически везде
    // Идентичное поведение в локальной разработке и CI
    // Не требуется ручная настройка Docker нигде
}
```

**Стратегия конфигурации (упрощенная)**
```yaml
# application-integration-test.yml (Универсальный)
spring:
  datasource:
    url: # Устанавливается динамически Testcontainers
    username: # Устанавливается динамически Testcontainers  
    password: # Устанавливается динамически Testcontainers
  jpa:
    hibernate:
      ddl-auto: create-drop  # Hibernate управляет схемой
  flyway:
    enabled: false  # Отключен для Testcontainers
```

---

## Заключение

**Текущий статус**: Testcontainers **полностью реализован** как унифицированная стратегия тестирования во всех средах.

**Достигнутые преимущества**:
- 100% консистентность продакшена во всех средах
- Идентичное поведение тестов в локальной разработке и CI
- Упрощенная архитектура с единым подходом к тестированию
- Автоматическое управление жизненным циклом контейнеров
- Не требуется ручная настройка Docker Compose
- Более быстрое выполнение CI без внешних зависимостей

**Руководящие принципы использования**:
- Используйте **unit тесты** для бизнес-логики с моками
- Используйте **BaseIntegrationTest** для всех интеграционных тестов (локально и CI)
- Все интеграционные тесты используют реальный MySQL через Testcontainers
- Не требуется конфигурация для конкретной среды
- Тесты полностью изолированы и воспроизводимы