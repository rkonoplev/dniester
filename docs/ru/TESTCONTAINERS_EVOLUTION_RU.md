# Эволюция Testcontainers и стратегия

Этот документ объясняет эволюцию стратегий тестирования в проекте Phoebe CMS и предоставляет руководство о том, когда использовать Testcontainers.

---

## Почему Testcontainers упомянут в документации

**Testcontainers упомянут как "Дополнительные улучшения (по желанию)"** в документации технического долга:

> - **Testcontainers**: Локальные интеграционные тесты без Docker Compose

Это отражает его статус как **опции для будущих улучшений**, а не текущей реализации.

---

## Исторический контекст: Зачем был нужен Testcontainers

### Первоначальное назначение
Testcontainers изначально рассматривался для:

1. **Локальных интеграционных тестов** - Запуск тестов без необходимости настройки Docker Compose
2. **Изоляции тестов** - Каждый набор тестов получает свой контейнер базы данных
3. **Автоматического управления жизненным циклом** - Контейнеры запускаются/останавливаются автоматически с тестами
4. **Опыта разработчика** - Не требуется ручная настройка базы данных

### Предыдущий подход (с Testcontainers)
```java
@Testcontainers
class IntegrationTest {
    @Container
    static MySQLContainer mysql = new MySQLContainer("mysql:8.0")
            .withDatabaseName("testdb")
            .withUsername("test")
            .withPassword("test");
    
    // Автоматически запускает/останавливает MySQL для каждого теста
}
```

---

## Эволюция текущей архитектуры

### Современный подход (стратегия на основе профилей)

**Локальная разработка:**
- **База данных H2** - Быстрая, в памяти для быстрых циклов разработки
- **Профиль**: `test`
- **Преимущества**: Мгновенный запуск, нет внешних зависимостей

**Среда CI/CD:**
- **MySQL через Docker Compose** - Реалистичная производственная среда
- **Профиль**: `ci`
- **Преимущества**: Соответствие продакшену, валидация миграций Flyway

**Продакшен:**
- **База данных MySQL** - Полная производственная настройка
- **Профиль**: `prod`
- **Преимущества**: Реальная производительность и поведение

### Сравнение архитектур

| Аспект | Testcontainers | Текущая стратегия профилей |
|--------|----------------|---------------------------|
| **Локальная скорость** | Медленнее (запуск контейнера) | Быстро (H2 в памяти) |
| **Надежность CI** | Сложная настройка | Стабильный Docker Compose |
| **Соответствие продакшену** | Высокое | Высокое (в CI) |
| **Сложность настройки** | Средняя | Низкая |
| **Использование ресурсов** | Выше | Ниже |

---

## Почему мы отошли от Testcontainers

### Технические причины
1. **Сложность CI/CD** - Трудно надежно настроить в GitHub Actions
2. **Влияние на производительность** - Медленнее чем H2 для локальной разработки
3. **Накладные расходы ресурсов** - Каждый тест требует запуска/остановки контейнера
4. **Проблемы Docker-in-Docker** - Осложнения в контейнеризованных CI средах

### Стратегические причины
1. **Гибкость на основе профилей** - Разные базы данных для разных сред
2. **Более простое обслуживание** - Меньше движущихся частей в тестовой инфраструктуре
3. **Лучший опыт разработчика** - Мгновенное выполнение локальных тестов
4. **Уверенность в продакшене** - CI использует реальную производственную базу данных

---

## Когда использовать Testcontainers

### ✅ Рекомендуемые сценарии

**1. Сложные взаимодействия с базой данных**
- Тестирование хранимых процедур
- Специфичные для базы данных функции (различия MySQL vs PostgreSQL)
- Сложные сценарии транзакций

**2. Тестирование нескольких баз данных**
- Тестирование против нескольких версий баз данных
- Валидация совместимости между базами данных
- Тестирование миграций баз данных

**3. Интеграция с внешними сервисами**
- Тестирование с Redis, Elasticsearch и т.д.
- Интеграция очередей сообщений (RabbitMQ, Kafka)
- Мокирование сторонних сервисов

**4. Изолированные тестовые среды**
- Когда тесты не должны мешать друг другу
- Тестирование сценариев повреждения данных
- Тестирование производительности с реалистичными объемами данных

### ❌ Не рекомендуемые сценарии

**1. Простые CRUD операции**
- Базовая персистентность сущностей
- Стандартные JPA операции
- Тестирование простой бизнес-логики

**2. Быстрые циклы разработки**
- Юнит-тестирование
- TDD рабочие процессы
- Быстрое прототипирование

**3. Среды с ограниченными ресурсами**
- Ограниченные ресурсы CI/CD
- Ноутбуки разработчиков с ограниченной RAM
- Общие среды разработки

---

## Стратегия реализации

### Текущая рекомендация: Сохранить подход на основе профилей

**Причины:**
- **Проверенная стабильность** - Надежно работает в CI/CD
- **Производительность** - Быстрая локальная разработка
- **Простота** - Легко понять и поддерживать
- **Гибкость** - Легко переключаться между базами данных

### Будущая интеграция Testcontainers (опционально)

Если вы решите добавить Testcontainers в будущем:

**1. Гибридный подход**
```java
@ActiveProfiles("testcontainers")
@Testcontainers
class DatabaseSpecificTest extends AbstractIntegrationTest {
    @Container
    static MySQLContainer mysql = new MySQLContainer("mysql:8.0");
    
    // Использовать только для специфичных для БД тестов
}
```

**2. Селективное использование**
- Сохранить H2 для быстрых интеграционных тестов в стиле юнит-тестов
- Использовать Testcontainers только для специфичных для базы данных сценариев
- Поддерживать Docker Compose для стабильности CI/CD

**3. Стратегия конфигурации**
```yaml
# application-testcontainers.yml
spring:
  datasource:
    url: # Устанавливается динамически Testcontainers
    driver-class-name: com.mysql.cj.jdbc.Driver
  jpa:
    hibernate:
      ddl-auto: create-drop
```

---

## Заключение

**Текущий статус**: Testcontainers остается **опциональным будущим улучшением**, которое может быть ценным для специфических сценариев тестирования.

**Рекомендация**: Продолжать с текущим подходом на основе профилей, если только вы не столкнетесь со специфическими случаями использования, которые требуют уникальных возможностей Testcontainers.

**Путь эволюции**: Архитектура проекта позволяет легкую интеграцию Testcontainers при необходимости, не нарушая существующую стабильную тестовую инфраструктуру.