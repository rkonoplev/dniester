ИНСТРУКЦИЯ ПО МИГРАЦИИ: Drupal 6 → News Platform (Spring Boot + MySQL 8)

ШАГ 1. Запуск временного MySQL 5.7 для дампа Drupal 6

Запуск: docker compose -f docker-compose.drupal.yml up -d
Логи: docker logs -f news-mysql-drupal6
Подключение: docker exec -it news-mysql-drupal6 mysql -u root -p (пароль root)
Проверка: SHOW DATABASES; USE a264971_dniester; SHOW TABLES;

ШАГ 2. Экспорт + импорт в новую базу

Экспорт: docker exec -i news-mysql-drupal6 mysqldump -uroot -proot a264971_dniester > db_data/drupal6_fixed.sql
Импорт: docker exec -i news-mysql-drupal6 mysql -uroot -proot dniester < db_data/drupal6_fixed.sql
Проверка: SHOW TABLES;

ЧТО МЫ ФАКТИЧЕСКИ ИМПОРТИРОВАЛИ В НОВУЮ БАЗУ

После миграции структура базы dniester выглядит так:

1. Пользователи (users)
   Источник: Drupal users
   Поля:
   - uid → id
   - name → username
   - mail → email
   - status → status (1=активен, 0=блокирован)

2. Роли (roles) и связка пользователей с ролями (user_roles)
   Источник: Drupal role, users_roles
   Заполняем таблицы:
   - roles (id, name)
   - user_roles (user_id, role_id)

3. Контент (content)
   Источник: node, node_revisions
   Целевая таблица: content (универсальная, без поля type)
   Поля:
   - nid → id
   - title → title
   - body → body
   - teaser → teaser
   - created (UNIX timestamp) → publication_date (DATETIME)
   - uid → author_id (FK → users.id)

   Важно: разные типы контента (story, page, book) больше НЕ разделяются и хранятся в одной таблице content.

4. Таксономия (terms, content_terms)
   Источник: term_data, vocabulary, term_node
   Таблицы:
   - terms (id, name, vocabulary)
   - content_terms (content_id, term_id)

5. Дополнительные CCK‑поля
   Источник: content_type_* таблицы (если есть)
   Целевая таблица: custom_fields (key-value)
   Поля:
   - nid → content_id
   - имя колонки → field_name
   - значение → field_value

ИТОГО в чистой схеме появляются таблицы:
- users
- roles
- user_roles
- content
- terms
- content_terms
- custom_fields

ШАГ 3. Нормализация схемы

Выполнить db_data/migrate_from_drupal6_universal.sql
Выполнить db_data/migrate_cck_fields.sql (если есть CCK)
Проверка результатa

ШАГ 4. Проблемы с кодировкой (UTF-8, кириллица)

Ошибка: Incorrect string value '\xD0...'
Причина: таблица создана в latin1
Проверка: SHOW CREATE TABLE a264971_dniester.node \G
Решение: пересоздать content с UTF8:
DROP TABLE IF EXISTS content;
CREATE TABLE content (...) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_general_ci;
Заново вставить данные из node + node_revisions

ШАГ 5. Экспорт clean_schema.sql
docker exec -i news-mysql-drupal6 mysqldump -uroot -proot dniester > db_data/clean_schema.sql

ШАГ 6. Подготовка MySQL 8.0

Если запускался неверно: docker compose -f docker-compose.yml down -v
Запуск: docker compose -f docker-compose.yml up -d mysql
Проверка логов: docker logs news-mysql (должно быть Creating database dniester)

ШАГ 7. Сброс пароля root при проблемах

docker stop news-mysql
docker run -it --rm --name mysql-fix -v news-platform_mysql_data:/var/lib/mysql mysql:8.0 --skip-grant-tables --skip-networking
В другом окне: docker exec -it mysql-fix mysql
В MySQL:
FLUSH PRIVILEGES;
ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'root';
ALTER USER 'root'@'%' IDENTIFIED WITH mysql_native_password BY 'root';
Остановить mysql-fix, снова запустить MySQL 8.0

ШАГ 8. Импорт финального дампа
docker exec -i news-mysql mysql -uroot -proot dniester < db_data/clean_schema.sql

ШАГ 9. Проверка

Список таблиц: SHOW TABLES;
Количество: SELECT COUNT(*) FROM content; (ожидание ~12186 строк)

КРАТКИЙ ПЛАН:

Поднять MySQL 8.0
Импортировать clean_schema.sql
Проверить наличие таблиц и данных

ОПИСАНИЕ SQL-ФАЙЛОВ ДЛЯ МИГРАЦИИ

В процессе миграции было создано несколько SQL-файлов, каждый со своей целью:

drupal6_fixed.sql
Чистый дамп исходной базы Drupal 6, перелитый в базу dniester внутри MySQL 5.7.
Использовался для того, чтобы унифицировать работу и иметь новый старт.

migrate_from_drupal6_universal.sql
Основной миграционный скрипт. Создаёт новые таблицы (users, roles, user_roles, content, terms, content_terms) и переносит очищенные данные из старых таблиц Drupal.
Это главный шаг миграции.

detect_custom_fields.sql
Вспомогательный файл. Проверяет, есть ли в базе таблицы вида content_type_*.
Если в результате выполнения запросов список пуст → CCK-полей не было.
Если вернулись строки → в базе были кастомные поля, созданные через модуль CCK.

migrate_cck_fields.sql
Дополнительный скрипт, используется только если реально есть content_type_* таблицы. Перекладывает их данные в универсальную таблицу custom_fields (схема key → value).
Если CCK не использовался, выполнять не нужно.

clean_schema.sql
Финальный дамп после нормализации схемы (результат выполнения migrate_from_drupal6_universal.sql и при необходимости migrate_cck_fields.sql). Этот файл и загружается в MySQL 8.0 для работы News Platform.

КАК ПРОВЕРИТЬ, ЕСТЬ ЛИ У ТЕБЯ CUSTOMFIELDS?

В MySQL 5.7 (контейнер news-mysql-drupal6) выполни команду:
SHOW TABLES LIKE 'content_type%';

Если список вернулся пустым → у тебя нет CCK полей.
Если есть строки вроде content_type_article, content_type_news и др. → значит были кастомные поля, их можно переложить при необходимости через migrate_cck_fields.sql.

ДОПОЛНИТЕЛЬНАЯ ПРОВЕРКА В НОВОЙ БАЗЕ

Если контейнер со старым Drupal 6 (MySQL 5.7) уже удалён и таблицы content_type_* недоступны, проверить наличие кастомных CCK-полей можно в новой базе dniester.

Выполни:
SELECT COUNT(*) FROM custom_fields;

Если результат = 0 → кастомных полей в Drupal 6 не было, либо они не мигрированы.
Если результат > 0 → значит в старой базе они существовали и были перенесены как key-value записи в таблицу custom_fields.

ПОСЛЕ ЗАВЕРШЕНИЯ МИГРАЦИИ

Когда вы удостоверились, что база clean_schema.sql успешно импортирована в MySQL 8.0 (контейнер news-mysql), временное окружение Drupal 6 больше не требуется.

Docker volumes:

✅ news-platform_mysql_data → оставить (используется MySQL 8.0 контейнером news-mysql).
❌ news-platform_mysql_data_drupal6 → можно удалить (это временный том для миграции Drupal 6).
Далее есть два варианта действий:

ВАРИАНТ 1 — просто остановить контейнер Drupal 6 и оставить volume «на всякий случай»:
docker stop news-mysql-drupal6

ВАРИАНТ 2 — полностью удалить контейнер и лишний volume (рекомендуется после успешного экспорта):
docker compose -f docker-compose.drupal.yml down -v

После этого у вас останется только рабочий MySQL 8.0 (контейнер news-mysql) и его volume news-platform_mysql_data, которые нужны для дальнейшей работы News Platform.

ЗАПУСК ПРОЕКТА

После того как новая база clean_schema.sql готова и импортирована, можно запускать проект.

Варианты:

ВАРИАНТ А — только база (MySQL для проверки данных)

Остановить старое окружение:
docker compose -f docker-compose.yml down -v
Поднять только MySQL:
docker compose -f docker-compose.yml up -d mysql
Проверить логи:
docker logs -f news-mysql
Импортировать базу (если ещё не залита):
docker exec -i news-mysql mysql -uroot -proot dniester < db_data/clean_schema.sql
Проверить содержимое:
docker exec -it news-mysql mysql -uroot -proot -e "SHOW TABLES;" dniester
docker exec -it news-mysql mysql -uroot -proot -e "SELECT COUNT(*) FROM content;" dniester
ВАРИАНТ Б — полное окружение (MySQL + backend Spring Boot)

Убедиться, что создан файл .env.dev с настройками:
MYSQL_ROOT_PASSWORD=root
MYSQL_DATABASE=dniester
SPRING_LOCAL_PORT=8080
SPRING_DATASOURCE_URL=jdbc:mysql://mysql:3306/dniester?useUnicode=true&characterEncoding=utf8mb4&useSSL=false
SPRING_DATASOURCE_USERNAME=root
SPRING_DATASOURCE_PASSWORD=root

Запустить сервисы:
docker compose --env-file .env.dev up -d

В итоге:

news-mysql → база MySQL 8 с данными
news-app → приложение Spring Boot
При необходимости импортировать базу:
docker exec -i news-mysql mysql -uroot -proot dniester < db_data/clean_schema.sql

Проверить базу:
docker exec -it news-mysql mysql -uroot -proot -e "SELECT COUNT(*) FROM content;" dniester

Проверить логи приложения:
docker logs -f news-app

Проверить API в браузере:
http://localhost:8080

КРАТКО (TL;DR):
docker compose --env-file .env.dev up -d
docker exec -i news-mysql mysql -uroot -proot dniester < db_data/clean_schema.sql
docker exec -it news-mysql mysql -uroot -proot -e "SELECT COUNT(*) FROM content;" dniester

ЕЖЕДНЕВНЫЙ ЗАПУСК ПРОЕКТА (БЕЗ ПОВТОРНОГО ИМПОРТА БАЗЫ)

Важно: НЕ нужно каждый день снова импортировать clean_schema.sql.
База сохраняется в Docker volume news-platform_mysql_data и переживает перезагрузки компьютера и контейнеров.

Правила:

Каждый день утром запускаем:
docker compose --env-file .env.dev up -d
База и данные уже будут доступны.
Удалить volume (и потерять данные) можно только если выполнить:
docker compose down -v (так делать не нужно в ежедневной работе!)
Что должно быть в Docker:

Контейнеры: news-mysql (и при полном старте ещё news-app)
Volume: news-platform_mysql_data
Старый контейнер для миграции Drupal (news-mysql-drupal6) и его том news-platform_mysql_data_drupal6 можно удалить.

Проверка:
docker ps
docker volume ls | grep news-platform

Ожидаем:

Containers: news-mysql (и news-app если запускаем приложение)
Volumes: news-platform_mysql_data