package com.example.newsplatform.entity;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Index;
import jakarta.persistence.ManyToMany;
import jakarta.persistence.PrePersist;
import jakarta.persistence.PreUpdate;
import jakarta.persistence.Table;
import jakarta.persistence.UniqueConstraint;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import java.util.HashSet;
import java.util.Locale;
import java.util.Set;

/**
 * Entity representing a taxonomy term used to classify news content.
 *
 * Each term belongs to a specific vocabulary (e.g., category, tag) and can be associated with multiple news articles.
 *
 * Portability notes:
 * - MySQL: UNIQUE(name, vocabulary) is typically case-insensitive with default *_ci collations.
 * - PostgreSQL: for case-insensitive uniqueness, consider a functional unique index on LOWER(name), LOWER(vocabulary)
 *   in a DB migration (cannot be expressed via JPA annotations).
 */
@Entity
@Table(
        name = "terms",
        indexes = {
                // Unique(name, vocabulary) already creates a composite index. Add a separate index for vocabulary lookups.
                @Index(name = "idx_term_vocabulary", columnList = "vocabulary")
        },
        uniqueConstraints = {
                @UniqueConstraint(columnNames = {"name", "vocabulary"})
        }
)
public class Term {

    /**
     * Unique identifier of the term.
     */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * Display name of the term (e.g., Science, Sports).
     */
    @NotBlank(message = "Term name is required")
    @Size(max = 255)
    @Column(nullable = false, length = 255)
    private String name;

    /**
     * Vocabulary that groups related terms (e.g., category, tag, region).
     */
    @NotBlank(message = "Vocabulary is required")
    @Size(max = 100)
    @Column(nullable = false, length = 100)
    private String vocabulary;

    /**
     * Articles associated with this term (inverse side).
     * The owning side is defined in News.terms.
     */
    @ManyToMany(mappedBy = "terms", fetch = FetchType.LAZY)
    private Set<News> newsArticles = new HashSet<>();

    /** Default constructor required by JPA. */
    public Term() {
    }

    /** Convenience constructor without id. */
    public Term(String name, String vocabulary) {
        this.name = name;
        this.vocabulary = vocabulary;
    }

    /** Constructor with id (use carefully; id is usually generated by the DB). */
    public Term(Long id, String name, String vocabulary) {
        this.id = id;
        this.name = name;
        this.vocabulary = vocabulary;
    }

    /**
     * Normalizes values for consistency and portability.
     * - Trims name.
     * - Trims and lowercases vocabulary using ROOT locale.
     */
    @PrePersist
    @PreUpdate
    private void normalize() {
        if (name != null) {
            name = name.trim();
        }
        if (vocabulary != null) {
            vocabulary = vocabulary.trim().toLowerCase(Locale.ROOT);
        }
    }

    // === Getters and Setters ===

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getVocabulary() {
        return vocabulary;
    }

    public void setVocabulary(String vocabulary) {
        this.vocabulary = vocabulary;
    }

    public Set<News> getNewsArticles() {
        return newsArticles;
    }

    public void setNewsArticles(Set<News> newsArticles) {
        this.newsArticles = newsArticles;
    }

    // === Relationship Helpers (bidirectional consistency) ===

    public void addNews(News news) {
        if (news == null) {
            return;
        }
